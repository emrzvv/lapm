# Абстрактные методы и классы, интерфейсы

## Абстрактные методы

**Абстрактный метод** (abstract method) - это не имеющий тела виртуальный метод, который должен быть переопределён в абстрактных классах.

В Java абстрактный метод объявляется модификатором `abstract`, при этом вместо тела стоит `;`

**Абстрактный класс** (abstract class) - это класс, имеющий абстрактные методы, которые объявлены либо в нём самом, либо унаследованы от базовых классов и не переопределены. Задаётся модификатором `abstract`.

Важное отличие абстрактного класса от обычного заключается в том, что нельзя создать объект экземплярного класса. Абстрактные классы призваны предоставлять базовый функционал для классов-наследников. А производные классы уже реализуют функционал.

Пример:
```java
abstract class Animal() {
    private String species;
    
    public Animal(String species) {
        this.species = species;
    }

    public abstract void speak();
}

class Dog extends Animal() {
    private String breed;

    public Dog(String breed) {
        super("dog);
        this.breed = breed;
    }

    public void speak() {
        System.out.println("baw");
    }
}
```

## Интерфейсы

**Интерфейс** (interface) - тип данных, представляющий собой набор абстрактных методов.

Механизм наследования очень удобен, но он имеет свои ограничения. В частности мы можем наследовать только от одного класса. В Java подобную проблему частично позволяют решить интерфейсы. Интерфейсы определяют некоторый функционал, не имеющий конкретной реализации, который затем реализуют классы, применяющие эти интерфейсы. Один класс может применить множество интерфейсов.

Предназначение интерфейса - служить контрактом между разработчиком некоторого класса и разработчиком программного кода, используещего этот класс.

*Замечание: аналог интерфейса - чистый абстрактный класс, в котором нет экземплярных полей и неабстрактных экземплярных методов.*

Реазихзация интерфейса (interface implementation) - это класс, являющийся подтипом этого интерфейса. Если этот класс не абстрактный, то в нём должны быть определены **все методы интерфейса без исключения**.

Класс может реализовывать сразу несколько интерфейсов, это частично компенсирует отсутствие множественного наследования в Java.

Пример: 
```java
public interface Swimmable {
    void swim();
}

public class Duck implements Swimmable {
    public void swim() {
        ... do something
    }
}

usage:

Duck duck = new Duck();
duck.swim();
```

Интерфейс может быть наследован от других интерфейсов, которые перечисляются в его объявлении после ключевого слова `extends`.

Пример:
```java
interface MovableShape {
    double x();
    double y();
    void move(double dx, double dy);
}

interface ClosedShape() {
    double perimetr();
    double area();
}

interface Polygon extends MovableShape, ClosedShape {
    boolean convex(); // проверка на выпуклость
}
```

В отличие от классов, в Java для интерфейсов реализовано множественное наследование.

Класс `X` называется **экземплярным вложением** в классе `Y`, если у методов класса `X` есть доступ к внутреннему состоянию объекта класса `Y`. При этом класс `Y` называется объемлющим классом.

Класс `X` называется статическим вложенным классом в классе `Y`, если у методов `X` доступны статические поля `Y`.

В Java объявление вложенного класса выглядит как обычное объявление класса, расположенного внутри тела объемлющего класса. При этом объявление статического вложенного класса объявляется с модификатором static.

Пример:
```java
public class Airplane {
    private String name, id, flight;
    private Wing leftWing = new Wing("Red", "x3");
    private Wing rightWing = new Wing("Green", "x3");

    public Airplane(String name, String id, String flight) {
        this.name = name;
        this.id = id;
        this.flight = flight;
    }

    private class Wing {
        String color, model;
        
        private Wing(String color, String model) {
            this.color = color;
            this.model = model;
        }
    }
}

```