## Ковариантность массивов
_**Утверждение**: в Java массивы ковариантны. Если класс `S` является наследником класса `T`, то тип `S` является подтипом `T`._

В частности ковариантность массивов позволяет написать следующее:

```Java
Integer[] ints = new Integer[10];
Numbers[] numbers = ints;
```

*Пример:* что будет после попытки присвоить `numbers` ссылки на объект, тип которого не `Integer`:
```Java 
numbers [0] = 3.14;
```
*Результат:(при компиляции ошибки не произойдет в силу ковариантности, но во время исполнения программа аварийно завершится с исключением)*
```Java
"java.lang.ArrayStoreExeption"
```
*Утверждение: Если бы удалось положить ссылку `Double` в `numbers`, то эта ссылка бы очутилась в массиве `int`, в котором должны храниться только ссылки на `Integer`.*

## Инвариантность обобщенных классов 

*Пример: с классом `Stack` в обобщенном варианте*
```Java
Stack<Integer> ints = new Stack<Integer>();
Stack<Numbers> = ints
// выше делали похожую операцию 
// ошибка возникнет на этапе компиляции, а не на этапе исполнения
```
*Результат:*
```Java
error: incompatible types
Stack<Number> numbers = ints;
                        ^
```
*Комментарий:*
- Это происходит, потому что обобщенные классы в Java **инвариантны**!

Т.е. если `G` - обобщенный класс, класс `S` - наследник класса `T`, то классы `G<S>` и `G<T>` отношением наследования не связаны.

*Комментарий:*
- Если обобщенный класс `DerivedStack<T>` - наследник `Stack<T>`, то `DerivedStack<Integer>` - наследник `Stack<Integer>`

## Шаблоны обобщенных классов 

_**Замечание:** Инваринатность обобщенных классов, на первый взгляд, ограничивает возможность полиморфной обработки объектов этих классов. Например, наивно написанный метод для вывода содержимого стека `Number`'ов будет непригоден для вывода стеков `Integer`'ов_
```Java
public static void printStack(Stack<Number> stack) {
    while (!stack.empty()) {
        Number x = stack.pop();
        System.out.println(x);
    }
}
```
Указанный выше метод непригоден для `Integer`. Для обхода подобного будем делать следующее.

**Определение:** Шаблон обобщенного класса `G` - это неявный супертип(более глобальный тип данных) для любого класса, поражденного из `G`. Шаблон получается параметризацией класса `G` специальным символом `?`. Например `Stack<?>`.

## Особеенности шаблонов 

1. **Можно** объявлять переменную типа "шаблон", но **невозможно** создать его объект.

    *Пример:*
    ```Java
    // Так можно
    Stack<?> x; // correct

    // Так нельзя
    x = new Stack<?> // error fuck u leatherman
    ```
    _**Замечание:** В данном случае мы над переменной понимаем не только локальные переменные, но и формальные параметры методов, поля, элементы массивов._

    *Пример: массив с элементами типа "шаблон"*
    ```Java
    Stack<?>[] a = new Stack<?>[10];
    ```

2. Если тип переменной - шаблон некоторого обобщенного класса `G`, то этой переменной можно присвоить ссылку на любой объект класса `G`, независимо от того, какой фактический типовой параметр был передан классу `G` при создании объекта.

    ```Java
    x = new Stack<Integer>;
    x = new Stack<Float>;
    ```
    *Пример:* полимофизм на основе шаблонов.
    ```Java
    public class Test {
        public static void printStack(Stack<?> stack) {// теперь используем обобщенный шаблон, раньше был Numbers, а стал "?"
            while (!stack.empty()) {
                Number x = stack.pop();
                System.out.println(x);
            }
        }
    }
    ```

    ```Java
    public static void main(String[] args) {
        Stack<Integer> s = new Stack<Integer>();
        s.push(1);
        s.push(2);
        s.push(3);
        printStack(s);
    }
    ```
    _**Замечание**: Метод pop шаблона `Stack<?>` возвращает Number - верхняя граница формального типового параметра обобщенного класса `Stack` (см. предыдущую лекцию)_

## Частичные шаблоны 

_**Утверждение:** Если обобщенный класс имеет несколько формальных типовых параметров, то возможно получить **частичный шаблон**, передав классу `?` вместо части фактических типовых параметров_

```Java
Map<Integer, ?> intMap;
// Правильно 
intMap = new Map<Integer, String>(); // correct

// Это тоже пойдет
intMap = new Map<Integer, Float>(); // corret

// А за такое suck some dick
intMap = new Map<Double, String>(); // ERROR!
```

Последнее присваивание вызовет ошибку компиляции, потому что первый фактический параметр обобщенного класса `Map` не `?` и даже не `Double`, а `Integer`!

## Шаблоны, ограниченные сверху
Как было показано в примере о методе `pop()` шаблон `Stack<?>`, фактический параметр `?` имеет верхнюю границу, по умолчанию совпадает с верхней границей соответвующего формального параметра обобщенного класса.

*Пример*: Верхней границей `?` в `Stack<?>` является `Number`, поэтому `pop()` для `Stack<?>` возвращает `Number`.

_**Замечание**: Верхнюю границу в шаблоне `?` можно уточнить так:_
```Java
G<..., ? extends X, ...>
```
_**Замечание**: Уточнение верхней границы сузит количество подтипов шаблона:_
```Java
Stack<Float> floats = new Stack<Float>();
Stack<?> numbers = floats;
Stack<? extends Integer> ints = floats; // ERROR! 
```