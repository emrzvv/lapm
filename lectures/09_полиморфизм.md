# Полиморфизм

Полиморфизм в ЯП и теории типов - способность функции или метода обрабатывать данные разных типов. Принцип полиморфизма заключается в том, что один и тот же фрагмент кода может работать с разными типами данных.

## Особенности шаблонов обобщённых классов

1. Шаблоны можно объявлять следующм образом
```Java
Stack<?> x; //ok
x = new Stack<?> // not ok ERROR 
```
2. Еще пример объявления шаблона
```Java
x = new Stack<Integer>();
x = new Stack<Float>(); 
```

*Вид обобщенного класса `Stack`*(был еще лекции 2 назад):
```Java
import java.util.Arrays();

public class Stack<T> {
    private int count = 0;
    private Object[] buf = new Object[30];
    public boolean empty() { return count == 0; }
    public void push(T x) { // параметр обощаем, класс не зависим от него
        if (count == buf.lenght) {
            buf = Arrays.CopyOf(buf, buf.lenght * 2);
        }
        buf[count++] = x;
    }
    public T pop() {
        if (empty()) {
            throw new RuntimeExeption("emptySatck");
        }
        return (T)buf[--count];
    }
}
```

*Утверждение:* У шаблона, ограниченного сверху, недоступны методы, тип параметров которых соответствует `?` в шаблоне. Например, у шаблона `Stack<?>` не доступен метод `push()`:
```Java
Stack<? extends Integer> number = new Stack<Integer>();
number.push(10); // работать не будет 
```
**ПОЯСНЕНИЕ:** Переменнная `numbers` может содержать ссылку на `Stack<Float>` (см. 1) и тогда передача `push()` целого числа может оказаться некоректной.

**Замечание:** Применительно к контейнерным обобщенным классам можно сказать, что использование шаблонов не позволяет написать полиморфный метод, осуществляющий запись новых значений в объект контейнерного класса.

## Шаблоны, ограниченные снизу

<u>**Утверждение**</u>: Шаблоны можно так же ограничивать снизу.
```Java
G<..., ? super X, ...>
```
<u>**Утверждение**</u>: Подтипом такого шаблона будут все полученные из `G` класса, у которых в качестве соответсвующего фактического типового параметра выступает `X` или любой суперкласс `Х`.

```Java
Stack<? super Integer>();
ints = new Stack<Number>();
ints = new Stack<Float>();
```

<u>**Утверждение**:</u> У ограниченного снизу шаблона контейнерного класса можно вызвать методы для записи значений того класса, которым он ограничен.

<u>**Пример**:</u>
```Java
Stack<? super Integer> ints = new Stack<Number>();
ints.push(10) // ok, но pop() вызвать мы не сможем
```

## Методы, недоступные у шаблонов, ограниченных снизу

<u>**Утверждение**:</u> У шаблона, ограниченного снизу, **не доступны методы, тип возвращаемого значения которых соответствует шаблону**, например, у шаблона `Stack<?>` не доступен метод `pop()`:
```Java
Stack<? super Integer> ints = new Stack<Integer>();
ints.push(10);
int x = ints.pop(); // не будет работать
```

<u>**ПОЯСНЕНИЕ**</u>: Переменная `ints` может содержать ссылку на `Stack<Numbers>` и тогда метод `pop()` может возвратить, например, `Float`! 

<u>**Замечание**:</u> Применительно к контейнерным классам, можно сказать, что **использование их шаблонов, ограниченных снизу не позволяет написать полиморфный метод, осуществляющий чтение значений из объекта контейнерного класса**.

<u>*Пример*:</u>
```Java
Producer extends and customer super // шок
```

<u>**Утверждение:**</u> Так как одним из наследников класса `Number` является класс `BigInteger`, представляющий числа произвольной разрядности, в отличие от `Integer`, класс `BigInteger` может иметь наследников.

<u>**Задача**:</u> Напишем метод, который переписывает элементы стека `BigInteger`'ов в стек `BigInteger`'ов `Number`'ов.

```Java
public static void pushReversed(
    Stack<? super BigInteger> dest, 
    Stack<? extends BigInteger> src) {
        while(!src.empty()) {
            dest.push(src.pop());
        }
    }
```

<u>**Замечание**:</u> Данный метод реализовывает принцип **PECS**: `src`(Producer) поставляет значения и ограничивается сверху, `dest`(Customer) принимает значения и ограничивается снизу.

<u>**Замечание по типовым параметрам у методов**:</u>
- Метод `pushReversed()` из предыдущего примера плох тем, что ориентируется на списки `BigInteger`. Он полиморфен в том смысле, что в качестве параметра `src` ему можно передать список объектов производного от `BigInteger` класса, а в качестве `dest` - список объектов базового для `BigInteger` класса.

<u>**Замечание**:</u> В Java методы могут иметь типовые параметры, тогда `pushReversed` будет иметь вид:
```Java
public static <T extends Number> void pushReversed(
    Stack<? super T> dest, Stack<? extends T> src) {
        while(!src.empty()) {
            dest.push(src.pop());
        }
    }
```

## Объявление и вызов обобщенного метода

<u>**Определение**:</u> 
- <font color=green>Обобщенный метод</font> - это статический или экземплярный метод класса, имеющий формальные типовые параметры.

<u>**Замечание**:</u> В объявлении метода типовые параметры непосредственно предшествут типу возвращаемого значения метода.

<u>**Вызов статического обобщенного метода запишем следующим образом**:</u>
```Java
имя_класса<фактич.типовые параметры> имя_метода(...)
```
<u>**Вызов экземплярного обобщенного метода запишем следующим образом**:</u>
```Java
объект<факт.типовые параметры> имя_метода(...)
```
